let x = i32(flat_index % params.width);
let y = i32(flat_index / params.width);
let center = sample_elevation(x, y);

if (center <= 0.0) {
  let ocean = vec4<f32>(0.03, 0.16, 0.32, 1.0);
  shaded_rgba[flat_index] = pack_rgba8(ocean);
  return;
}

let left = sample_elevation(x - 1, y);
let right = sample_elevation(x + 1, y);
let top = sample_elevation(x, y - 1);
let bottom = sample_elevation(x, y + 1);

let dx = (right - left) * params.elevation_scale;
let dy = (bottom - top) * params.elevation_scale;
let normal = normalize(vec3<f32>(-dx, -dy, 1.0));

let sun_rad = radians(params.sun_angle);
let light_dir = normalize(vec3<f32>(cos(sun_rad), sin(sun_rad), 1.0));
let diffuse = max(dot(normal, light_dir), 0.0);
let ambient = 0.2;
let light = ambient + diffuse * (1.0 - ambient);

let lowland = vec3<f32>(0.56, 0.60, 0.45);
let highland = vec3<f32>(0.79, 0.74, 0.62);
let base_land = mix(lowland, highland, clamp(center, 0.0, 1.0));
let lit = base_land * light;

shaded_rgba[flat_index] = pack_rgba8(vec4<f32>(lit, 1.0));
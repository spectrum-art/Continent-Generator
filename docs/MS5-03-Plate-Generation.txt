struct PlateParams {
  width: u32,
  height: u32,
  plate_count: u32,
  seed: u32,
  inv_width: f32,
  inv_height: f32,
  plate_warp_amplitude: f32,
  plate_warp_roughness: f32,
  plate_warp_frequency: f32,
  _pad0: f32,
  _pad1: f32,
  _pad2: f32,
}

struct ActivePlate {
  pos: vec2<f32>,
  weight: f32,
  _pad_weight: f32,
  velocity: vec2<f32>,
  _pad_velocity: vec2<f32>,
}

struct WeightedSeed {
  pos: vec2<f32>,
  weight: f32,
  _pad_weight: f32,
}

const ACTIVE_COUNT: u32 = 15u;
const FOSSIL_COUNT: u32 = 30u;
const PLUME_COUNT: u32 = 5u;
const PI2: f32 = 6.28318530718;
const ACTIVE_MAX_WEIGHT: f32 = 0.65;
const FOSSIL_MAX_WEIGHT: f32 = 0.32;

@group(0) @binding(0) var<storage, read_write> plate_id: array<u32>;
@group(0) @binding(1) var<storage, read_write> plate_velocity: array<vec2<f32>>;
@group(0) @binding(2) var<storage, read_write> fossil_id: array<u32>;
@group(0) @binding(3) var<storage, read_write> plume_mask: array<f32>;
@group(0) @binding(4) var<uniform> params: PlateParams;

var<private> active_plates: array<ActivePlate, ACTIVE_COUNT>;
var<private> fossil_plates: array<WeightedSeed, FOSSIL_COUNT>;
var<private> plume_points: array<vec2<f32>, PLUME_COUNT>;

fn hash_u32(x: u32) -> u32 {
  var h = x;
  h = h ^ (h >> 16u);
  h = h * 0x7feb352du;
  h = h ^ (h >> 15u);
  h = h * 0x846ca68bu;
  h = h ^ (h >> 16u);
  return h;
}

fn hash_to_unit(x: u32) -> f32 {
  return f32(hash_u32(x)) * (1.0 / 4294967295.0);
}

fn seeded_hash_2d(p: vec2<u32>, seed: u32) -> u32 {
  var h = p.x * 374761393u + p.y * 668265263u;
  h = h ^ (seed * 2246822519u + 3266489917u);
  return hash_u32(h);
}

fn fade2(t: vec2<f32>) -> vec2<f32> {
  return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

fn gradient_from_hash(h: u32) -> vec2<f32> {
  switch (h & 15u) {
    case 0u: { return vec2<f32>(1.0, 0.0); }
    case 1u: { return vec2<f32>(0.9238795, 0.3826834); }
    case 2u: { return vec2<f32>(0.70710677, 0.70710677); }
    case 3u: { return vec2<f32>(0.3826834, 0.9238795); }
    case 4u: { return vec2<f32>(0.0, 1.0); }
    case 5u: { return vec2<f32>(-0.3826834, 0.9238795); }
    case 6u: { return vec2<f32>(-0.70710677, 0.70710677); }
    case 7u: { return vec2<f32>(-0.9238795, 0.3826834); }
    case 8u: { return vec2<f32>(-1.0, 0.0); }
    case 9u: { return vec2<f32>(-0.9238795, -0.3826834); }
    case 10u: { return vec2<f32>(-0.70710677, -0.70710677); }
    case 11u: { return vec2<f32>(-0.3826834, -0.9238795); }
    case 12u: { return vec2<f32>(0.0, -1.0); }
    case 13u: { return vec2<f32>(0.3826834, -0.9238795); }
    case 14u: { return vec2<f32>(0.70710677, -0.70710677); }
    default: { return vec2<f32>(0.9238795, -0.3826834); }
  }
}

fn perlin_noise_2d(p: vec2<f32>, seed: u32) -> f32 {
  let cell = vec2<i32>(floor(p));
  let frac = fract(p);
  let u = fade2(frac);

  let c00 = vec2<u32>(u32(cell.x), u32(cell.y));
  let c10 = vec2<u32>(u32(cell.x + 1), u32(cell.y));
  let c01 = vec2<u32>(u32(cell.x), u32(cell.y + 1));
  let c11 = vec2<u32>(u32(cell.x + 1), u32(cell.y + 1));

  let g00 = gradient_from_hash(seeded_hash_2d(c00, seed ^ 0x9e3779b9u));
  let g10 = gradient_from_hash(seeded_hash_2d(c10, seed ^ 0x85ebca6bu));
  let g01 = gradient_from_hash(seeded_hash_2d(c01, seed ^ 0xc2b2ae35u));
  let g11 = gradient_from_hash(seeded_hash_2d(c11, seed ^ 0x27d4eb2fu));

  let d00 = frac - vec2<f32>(0.0, 0.0);
  let d10 = frac - vec2<f32>(1.0, 0.0);
  let d01 = frac - vec2<f32>(0.0, 1.0);
  let d11 = frac - vec2<f32>(1.0, 1.0);

  let n00 = dot(g00, d00);
  let n10 = dot(g10, d10);
  let n01 = dot(g01, d01);
  let n11 = dot(g11, d11);

  let nx0 = mix(n00, n10, u.x);
  let nx1 = mix(n01, n11, u.x);
  return mix(nx0, nx1, u.y);
}

fn fbm(p: vec2<f32>, base_frequency: f32, roughness: f32, octaves: u32, seed: u32) -> f32 {
  let rot = mat2x2<f32>(0.8, -0.6, 0.6, 0.8);
  var p_octave = rot * p + vec2<f32>(12.3, 45.6);
  var amplitude = 0.5;
  var frequency = base_frequency;
  var total = 0.0;
  var amplitude_sum = 0.0;

  for (var octave: u32 = 0u; octave < octaves; octave = octave + 1u) {
    let octave_noise = perlin_noise_2d(p_octave * frequency, seed + octave * 0x9e3779b9u) * 0.5 + 0.5;
    total = total + octave_noise * amplitude;
    amplitude_sum = amplitude_sum + amplitude;
    p_octave = rot * p_octave + vec2<f32>(12.3, 45.6);
    frequency = frequency * 2.0;
    amplitude = amplitude * roughness;
  }

  return total / max(amplitude_sum, 0.00001);
}

fn make_weight(v: f32, max_weight: f32) -> f32 {
  return pow(v, 4.0) * max_weight;
}

fn make_active_plate(id: u32) -> ActivePlate {
  let base = hash_u32(params.seed ^ (id * 747796405u + 2891336453u));
  let hx = hash_to_unit(base ^ 0x9e3779b9u);
  let hy = hash_to_unit(base ^ 0x85ebca6bu);
  let hw = hash_to_unit(base ^ 0xc2b2ae35u);
  let hs = hash_to_unit(base ^ 0x27d4eb2fu);
  let ha = hash_to_unit(base ^ 0x165667b1u);

  let speed = mix(1.0, 10.0, pow(hs, 3.0));
  let angle = ha * PI2;
  let direction = vec2<f32>(cos(angle), sin(angle));

  var plate: ActivePlate;
  plate.pos = vec2<f32>(hx * 2.0, hy);
  plate.weight = make_weight(hw, ACTIVE_MAX_WEIGHT);
  plate.velocity = direction * speed;
  return plate;
}

fn make_fossil_plate(id: u32) -> WeightedSeed {
  let fossil_seed = params.seed ^ 0x9E3779B9u;
  let base = hash_u32(fossil_seed ^ (id * 3266489917u + 668265263u));
  let hx = hash_to_unit(base ^ 0x243f6a88u);
  let hy = hash_to_unit(base ^ 0xb7e15162u);
  let hw = hash_to_unit(base ^ 0x8aed2a6bu);

  var plate: WeightedSeed;
  plate.pos = vec2<f32>(hx * 2.0, hy);
  plate.weight = make_weight(hw, FOSSIL_MAX_WEIGHT);
  return plate;
}

fn make_plume_point(id: u32) -> vec2<f32> {
  let plume_seed = params.seed ^ 0x85EBCA6Bu;
  let base = hash_u32(plume_seed ^ (id * 2246822519u + 374761393u));
  let px = hash_to_unit(base ^ 0x27d4eb2fu);
  let py = hash_to_unit(base ^ 0x165667b1u);
  return vec2<f32>(px * 2.0, py);
}

fn init_seed_arrays() {
  for (var i = 0u; i < ACTIVE_COUNT; i = i + 1u) {
    active_plates[i] = make_active_plate(i);
  }

  for (var i = 0u; i < FOSSIL_COUNT; i = i + 1u) {
    fossil_plates[i] = make_fossil_plate(i);
  }

  for (var i = 0u; i < PLUME_COUNT; i = i + 1u) {
    plume_points[i] = make_plume_point(i);
  }
}

@compute @workgroup_size(256, 1, 1)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  init_seed_arrays();

  let flat_index = gid.x;
  let cell_count = params.width * params.height;
  if (flat_index >= cell_count) {
    return;
  }

  let x = f32(flat_index % params.width);
  let y = f32(flat_index / params.width);
  let u_norm = x * params.inv_width;
  let v_norm = y * params.inv_height;
  let original_pos = vec2<f32>(u_norm * 2.0, v_norm);

  let macro_freq = params.plate_warp_frequency;
  let micro_freq = params.plate_warp_frequency * 10.0;
  let safe_macro_amp = min(params.plate_warp_amplitude, 0.8 / macro_freq);
  let safe_micro_amp = min(params.plate_warp_amplitude * 0.1, 0.4 / micro_freq);

  let macro_warp_x = (fbm(
    original_pos + vec2<f32>(17.3, -9.1),
    macro_freq,
    params.plate_warp_roughness,
    4u,
    params.seed ^ 0x243f6a88u
  ) * 2.0 - 1.0) * safe_macro_amp;
  let macro_warp_y = (fbm(
    original_pos - vec2<f32>(8.4, 21.2),
    macro_freq,
    params.plate_warp_roughness,
    4u,
    params.seed ^ 0x6a09e667u
  ) * 2.0 - 1.0) * safe_macro_amp;
  let macro_warp = vec2<f32>(macro_warp_x, macro_warp_y);
  let micro_warp_x = (fbm(
    original_pos + vec2<f32>(63.7, 11.4),
    micro_freq,
    params.plate_warp_roughness,
    3u,
    params.seed ^ 0xb7e15162u
  ) * 2.0 - 1.0) * safe_micro_amp;
  let micro_warp_y = (fbm(
    original_pos - vec2<f32>(19.2, 37.8),
    micro_freq,
    params.plate_warp_roughness,
    3u,
    params.seed ^ 0x8aed2a6bu
  ) * 2.0 - 1.0) * safe_micro_amp;
  let micro_warp = vec2<f32>(micro_warp_x, micro_warp_y);
  let warped_pos = original_pos + macro_warp + micro_warp;

  // Layer A: active plates.
  var best_id = 0u;
  var best_score = 1e20;
  var best_velocity = vec2<f32>(0.0, 0.0);
  for (var plate_idx = 0u; plate_idx < ACTIVE_COUNT; plate_idx = plate_idx + 1u) {
    let candidate = active_plates[plate_idx];
    let score = length(warped_pos - candidate.pos) - candidate.weight;
    if (score < best_score) {
      best_score = score;
      best_id = plate_idx;
      best_velocity = candidate.velocity;
    }
  }

  // Layer B: fossil plate IDs.
  var best_fossil_id = 0u;
  var best_fossil_score = 1e20;
  for (var fossil_idx = 0u; fossil_idx < FOSSIL_COUNT; fossil_idx = fossil_idx + 1u) {
    let candidate = fossil_plates[fossil_idx];
    let score = length(warped_pos - candidate.pos) - candidate.weight;
    if (score < best_fossil_score) {
      best_fossil_score = score;
      best_fossil_id = fossil_idx;
    }
  }

  // Layer C: mantle plume mask.
  let plume_radius = 0.24;
  var max_plume = 0.0;
  for (var plume_idx = 0u; plume_idx < PLUME_COUNT; plume_idx = plume_idx + 1u) {
    let plume_pos = plume_points[plume_idx];
    let d = distance(original_pos, plume_pos);
    let plume_val = clamp(1.0 - (d / plume_radius), 0.0, 1.0);
    max_plume = max(max_plume, plume_val);
  }

  plate_id[flat_index] = best_id;
  plate_velocity[flat_index] = best_velocity;
  fossil_id[flat_index] = best_fossil_id;
  plume_mask[flat_index] = max_plume;
}

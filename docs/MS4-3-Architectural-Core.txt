struct TopographyParams {
  width: u32,
  height: u32,
  seed: u32,
  _pad0: u32,
  mountain_radius: f32,
  mountain_height: f32,
  terrain_roughness: f32,
  terrain_frequency: f32,
}

@group(0) @binding(0) var<storage, read> kinematic_data: array<vec4<f32>>;
@group(0) @binding(1) var<storage, read> jfa_nearest: array<vec2<f32>>;
@group(0) @binding(2) var<storage, read> final_land_mask: array<f32>;
@group(0) @binding(3) var<storage, read_write> elevation: array<f32>;
@group(0) @binding(4) var<uniform> params: TopographyParams;

fn hash_u32(x: u32) -> u32 {
  var h = x;
  h = h ^ (h >> 16u);
  h = h * 0x7feb352du;
  h = h ^ (h >> 15u);
  h = h * 0x846ca68bu;
  h = h ^ (h >> 16u);
  return h;
}

fn hash_to_unit(x: u32) -> f32 {
  return f32(hash_u32(x)) * (1.0 / 4294967295.0);
}

fn seeded_hash_2d(p: vec2<u32>, seed: u32) -> u32 {
  var h = p.x * 374761393u + p.y * 668265263u;
  h = h ^ (seed * 2246822519u + 3266489917u);
  return hash_u32(h);
}

fn hash2(cell: vec2<i32>, salt: u32) -> vec2<f32> {
  let c = vec2<u32>(u32(cell.x), u32(cell.y));
  let h0 = seeded_hash_2d(c, params.seed ^ salt);
  let h1 = hash_u32(h0 ^ 0x9e3779b9u);
  return vec2<f32>(hash_to_unit(h0), hash_to_unit(h1));
}

fn fade2(t: vec2<f32>) -> vec2<f32> {
  return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

fn gradient_from_hash(h: u32) -> vec2<f32> {
  switch (h & 15u) {
    case 0u: { return vec2<f32>(1.0, 0.0); }
    case 1u: { return vec2<f32>(0.9238795, 0.3826834); }
    case 2u: { return vec2<f32>(0.70710677, 0.70710677); }
    case 3u: { return vec2<f32>(0.3826834, 0.9238795); }
    case 4u: { return vec2<f32>(0.0, 1.0); }
    case 5u: { return vec2<f32>(-0.3826834, 0.9238795); }
    case 6u: { return vec2<f32>(-0.70710677, 0.70710677); }
    case 7u: { return vec2<f32>(-0.9238795, 0.3826834); }
    case 8u: { return vec2<f32>(-1.0, 0.0); }
    case 9u: { return vec2<f32>(-0.9238795, -0.3826834); }
    case 10u: { return vec2<f32>(-0.70710677, -0.70710677); }
    case 11u: { return vec2<f32>(-0.3826834, -0.9238795); }
    case 12u: { return vec2<f32>(0.0, -1.0); }
    case 13u: { return vec2<f32>(0.3826834, -0.9238795); }
    case 14u: { return vec2<f32>(0.70710677, -0.70710677); }
    default: { return vec2<f32>(0.9238795, -0.3826834); }
  }
}

fn perlin_noise_2d(p: vec2<f32>) -> f32 {
  let cell = vec2<i32>(floor(p));
  let frac = fract(p);
  let u = fade2(frac);

  let c00 = vec2<u32>(u32(cell.x), u32(cell.y));
  let c10 = vec2<u32>(u32(cell.x + 1), u32(cell.y));
  let c01 = vec2<u32>(u32(cell.x), u32(cell.y + 1));
  let c11 = vec2<u32>(u32(cell.x + 1), u32(cell.y + 1));

  let g00 = gradient_from_hash(seeded_hash_2d(c00, params.seed ^ 0x9e3779b9u));
  let g10 = gradient_from_hash(seeded_hash_2d(c10, params.seed ^ 0x85ebca6bu));
  let g01 = gradient_from_hash(seeded_hash_2d(c01, params.seed ^ 0xc2b2ae35u));
  let g11 = gradient_from_hash(seeded_hash_2d(c11, params.seed ^ 0x27d4eb2fu));

  let d00 = frac - vec2<f32>(0.0, 0.0);
  let d10 = frac - vec2<f32>(1.0, 0.0);
  let d01 = frac - vec2<f32>(0.0, 1.0);
  let d11 = frac - vec2<f32>(1.0, 1.0);

  let n00 = dot(g00, d00);
  let n10 = dot(g10, d10);
  let n01 = dot(g01, d01);
  let n11 = dot(g11, d11);

  let nx0 = mix(n00, n10, u.x);
  let nx1 = mix(n01, n11, u.x);
  return mix(nx0, nx1, u.y);
}

fn fbm(p: vec2<f32>) -> f32 {
  let rot = mat2x2<f32>(0.8, -0.6, 0.6, 0.8);
  var p_octave = rot * p + vec2<f32>(12.3, 45.6);
  var amplitude = 0.5;
  var frequency = 1.0;
  var total = 0.0;
  var amplitude_sum = 0.0;

  for (var octave: u32 = 0u; octave < 4u; octave = octave + 1u) {
    let octave_noise = perlin_noise_2d(p_octave * frequency) * 0.5 + 0.5;
    total = total + octave_noise * amplitude;
    amplitude_sum = amplitude_sum + amplitude;
    p_octave = rot * p_octave + vec2<f32>(12.3, 45.6);
    frequency = frequency * 2.0;
    amplitude = amplitude * 0.5;
  }

  return total / max(amplitude_sum, 0.00001);
}

fn voronoi_f2_f1(p: vec2<f32>) -> f32 {
  let base = vec2<i32>(floor(p));
  var f1 = 1e9;
  var f2 = 1e9;

  for (var oy = -1; oy <= 1; oy = oy + 1) {
    for (var ox = -1; ox <= 1; ox = ox + 1) {
      let cell = base + vec2<i32>(ox, oy);
      let jitter = hash2(cell, 0xa511e9b3u);
      let point = vec2<f32>(f32(cell.x), f32(cell.y)) + jitter;
      let d = distance(p, point);
      if (d < f1) {
        f2 = f1;
        f1 = d;
      } else if (d < f2) {
        f2 = d;
      }
    }
  }

  return clamp(f2 - f1, 0.0, 1.0);
}

@compute @workgroup_size(256, 1, 1)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let flat_index = gid.x;
  let cell_count = params.width * params.height;
  if (flat_index >= cell_count) {
    return;
  }

  let mask = final_land_mask[flat_index];
  let nearest = jfa_nearest[flat_index];
  if (nearest.x < 0.0 || nearest.y < 0.0) {
    elevation[flat_index] = mask;
    return;
  }

  let x = i32(flat_index % params.width);
  let y = i32(flat_index / params.width);
  let p = vec2<f32>(f32(x), f32(y));
  let delta = p - nearest;
  let delta_len2 = dot(delta, delta);
  let dir = select(vec2<f32>(1.0, 0.0), normalize(delta), delta_len2 > 0.00001);

  let distance_to_fault = sqrt(delta_len2);
  let norm_dist = distance_to_fault / max(params.mountain_radius, 1.0);

  let fx = clamp(i32(round(nearest.x)), 0, i32(params.width) - 1);
  let fy = clamp(i32(round(nearest.y)), 0, i32(params.height) - 1);
  let fault_index = u32(fy) * params.width + u32(fx);
  let kin = kinematic_data[fault_index];

  var current_elevation = mix(0.05, 0.2, mask);
  var flexure = exp(-norm_dist * 4.0) * cos(norm_dist * 4.5);
  if (flexure < 0.0) {
    flexure = flexure * 0.65;
  }

  var master_amp = params.mountain_height;
  var normal_uplift = abs(kin.x) * 1.0;
  if (kin.x < 0.0) {
    normal_uplift = -normal_uplift;
  }
  let shear_uplift = kin.y * 0.15;
  var tectonic_vol = (normal_uplift + shear_uplift) * flexure * master_amp;

  let spine_var = fbm(nearest * 0.01) * 0.4 + 0.8;
  tectonic_vol = tectonic_vol * spine_var;

  let tangent = vec2<f32>(-dir.y, dir.x);
  let proj = dot(p, tangent);
  let phase = fbm(p * params.terrain_frequency * 0.5) * 5.0;
  let rib_wave = (sin(proj * params.terrain_frequency * 1.5 + phase) + 1.0) * 0.5;
  tectonic_vol = tectonic_vol * mix(0.2, 1.0, rib_wave);

  if (kin.z == 1.0 && mask == 0.0) {
    tectonic_vol = -abs(tectonic_vol) * 1.2;
  }

  current_elevation = current_elevation + tectonic_vol;

  let facets = voronoi_f2_f1(p * params.terrain_frequency * 2.5);
  current_elevation =
    current_elevation +
    (facets - 0.5) * params.terrain_roughness * max(tectonic_vol, 0.0);

  if (mask > 0.5) {
    current_elevation = current_elevation + fbm(p * 0.005) * 0.05;
  }

  elevation[flat_index] = clamp(current_elevation, 0.0, 1.0);
}

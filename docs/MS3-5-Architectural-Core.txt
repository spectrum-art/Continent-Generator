fn fbm(p: vec2<f32>) -> f32 {
  let rot = mat2x2<f32>(0.8, -0.6, 0.6, 0.8);
  var p_octave = rot * p + vec2<f32>(12.3, 45.6);
  var amplitude = 0.5;
  var frequency = 1.0;
  var total = 0.0;
  var amplitude_sum = 0.0;

  for (var octave: u32 = 0u; octave < 4u; octave = octave + 1u) {
    let octave_noise = perlin_noise_2d(p_octave * frequency) * 0.5 + 0.5;
    total = total + octave_noise * amplitude;
    amplitude_sum = amplitude_sum + amplitude;
    p_octave = rot * p_octave + vec2<f32>(12.3, 45.6);
    frequency = frequency * 2.0;
    amplitude = amplitude * 0.5;
  }

  return total / max(amplitude_sum, 0.00001);
}

@compute @workgroup_size(256, 1, 1)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let flat_index = gid.x;
  let cell_count = params.width * params.height;
  if (flat_index >= cell_count) {
    return;
  }

  if (final_land_mask[flat_index] < 0.5) {
    elevation[flat_index] = 0.0;
    return;
  }

  let x = i32(flat_index % params.width);
  let y = i32(flat_index / params.width);
  let u_norm = f32(x) / f32(params.width);
  let v_norm = f32(y) / f32(params.height);
  let sample_uv = vec2<f32>(u_norm * 2.0, v_norm);

  let base_noise = fbm(sample_uv * (params.terrain_frequency * 0.35));
  var current_elevation = 0.15 + (base_noise * 0.04);
  let radius = max(params.mountain_radius, 1.0);
  let radius_i = i32(ceil(radius));
  let radius2 = radius * radius;
  var min_dist = radius;
  var weighted_stress = 0.0;
  var total_weight = 0.0;

  let min_x = max(0, x - radius_i);
  let max_x = min(i32(params.width) - 1, x + radius_i);
  let min_y = max(0, y - radius_i);
  let max_y = min(i32(params.height) - 1, y + radius_i);

  for (var ny = min_y; ny <= max_y; ny = ny + 1) {
    for (var nx = min_x; nx <= max_x; nx = nx + 1) {
      let n_index = u32(ny) * params.width + u32(nx);
      let stress = fault_stress[n_index];
      if (abs(stress) <= 0.000001) {
        continue;
      }

      let dx = f32(nx - x);
      let dy = f32(ny - y);
      let dist2 = dx * dx + dy * dy;
      if (dist2 > radius2) {
        continue;
      }

      let distance = sqrt(dist2);
      if (distance < min_dist) {
        min_dist = distance;
      }

      let weight = 1.0 / (dist2 + 1.0);
      weighted_stress = weighted_stress + stress * weight;
      total_weight = total_weight + weight;
    }
  }

  if (total_weight > 0.0) {
    let avg_stress = weighted_stress / total_weight;
    let struct_noise = fbm(sample_uv * params.terrain_frequency) * 2.0 - 1.0;
    let warped_dist = min_dist + (struct_noise * params.terrain_roughness * (radius * 0.5));
    let base_falloff = max(1.0 - (warped_dist / radius), 0.0);
    let sigmoid_profile = smoothstep(0.0, 1.0, base_falloff);
    let base_uplift = avg_stress * sigmoid_profile * params.mountain_height;

    let alpine_noise = fbm(sample_uv * params.terrain_frequency * 2.5);
    let peaks = 1.0 - abs(alpine_noise * 2.0 - 1.0);
    let valleys = abs(fbm(sample_uv * params.terrain_frequency * 1.5 + vec2<f32>(5.0, 5.0)) * 2.0 - 1.0);
    let structure = mix(valleys, peaks, sigmoid_profile);
    let displacement =
      (structure - 0.5) *
      params.terrain_roughness *
      sigmoid_profile *
      params.mountain_height;

    current_elevation =
      current_elevation + base_uplift + displacement;
  }

  elevation[flat_index] = clamp(current_elevation, 0.0, 1.0);
}
